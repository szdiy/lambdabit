;;  Copyright (C) 2013
;;      "Mu Lei" known as "NalaGinrut" <NalaGinrut@gmail.com>
;;  This file is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.

;;  This file is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.

;;  You should have received a copy of the GNU General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

;; This module is used to compute the node to generate inner struct

(define-module (lambdabit compile)
  #:use-module (ice-9 getopt-long)
  #:use-module (ice-9 pretty-print)
  #:use-module (lambdabit utils)
  #:use-module (lambdabit back-end)
  #:use-module (lambdabit env)
  #:use-module (lambdabit reader)
  #:use-module (lambdabit parser)
  #:use-module (lambdabit front-end)
  #:use-module (lambdabit ir)
  #:use-module (lambdabit ast)
  #:use-module (lambdabit comp)
  #:use-module (lambdabit back-end)
  #:use-module (lambdabit assembler)
  #:use-module (lambdabit analysis)
  #:use-module (lambdabit sched)
  #:use-module (lambdabit tree-shaker)
  #:export (compile))

(define usage 
  "Usage: compile [options]* filename
 
   -h | --help         ==> Show this screen.
   -s | --size         ==> Display the size of the generated bytecode.
   -p | --parse        ==> Display post-parsing representation of the program.
   -f | --front        ==> Display post-front-end representation of the program.
   -S | --asm          ==> Display generated bytecode pre-assembly.
   -t | --status       ==> Display statistics about generated instructions.
   -o | --output       ==> Place the output into the given file.

 Written with GNU Guile by NalaGinrut<nalaginrut@gmail.com> (C)2013.
 ")
 
(define option-spec
  '((help (single-char #\h) (value #f))
    (size (single-char #\s) (value #f))
    (parse (single-char #\p) (value #f))
    (parse (single-char #\p) (value #f))
    (front (single-char #\f) (value #f))
    (asm (single-char #\S) (value #f))
    (status (single-char #\t) (value #f))
    (output (single-char #\o) (value #t))))

(define (outfile-gen file)
  (let ((hex-filename (string-append file ".hex")))
    (and (file-exists? hex-filename)
         (delete-file hex-filename))
    hex-filename))

(define (get-the-opts args) 
  (let ((len (length args)))
    (cond
     ((< len 1)
      (display usage)
      (primitive-exit 0))
     (else
      (cons "place-holder" ; getopt-long needs the first elem as the place-holder
            (list-head args (1- len)))))))

(define (compile . args)
  (define filename (get-the-file args))
  (define options (getopt-long (get-the-opts args) option-spec))
  (parameterize
    ((need-help (option-ref options 'help #f))
     (show-size (option-ref options 'size #f))
     (show-parsed (option-ref options 'parse #f))
     (show-front (option-ref options 'front #f))
     (print-asm (option-ref options 'asm #f))
     (show-status (option-ref options 'status #f))
     (outfile (option-ref options 'output #f)))
    (cond
     (need-help 
      (display usage)
      (primitive-exit)) ;; show help and exit.
     ((string=? filename "-")
      (do-compile (current-input-port) (current-output-port)))
     (else 
      (do-compile (open-input-file filename) 
                  (if outfile 
                      (open-output-file (outfile-gen outfile))
                      (current-output-port)))))))

(define (do-compile in-port out-port)
  (let* ((forms (read-program in-port))
         (node (parse-program forms global-env)))
    (when (show-parsed)
      (pretty-print (node->expr node)))
    (adjust-unmutable-references! node)
    ;; done first to expose more left-left-lambdas, help constant folding, etc.
    (copy-propagate!              node)
    (inline-left-left-lambda!     node) ; gives constant folding more to do
    (inline-calls-to-calls!       node) ; same
    (copy-propagate!              node) ; same
    (constant-fold!               node)
    (copy-propagate!              node) ; again, for cleanup
    ;; analysis needed by the back-end
    (mark-needed-global-vars!     node)
    (when (show-front)
      (pretty-print (node->expr node)))
    (let* ((ctx  (comp-node node (make-init-context)))
           (code (context-code ctx))
           (bbs  (code->vector code)))
      (resolve-toplevel-labels! bbs)
      (let ((prog (schedule (tree-shake! bbs))))
        (when (print-asm)
          (pretty-print prog))
        ;; output port is in a thunk to avoid creating result
        ;; files if compilation fails
        (let ((size (assemble prog out-port)))
          (when (show-size)
            (format #t "~a bytes\n" size)))))))
