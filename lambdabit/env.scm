;;  Copyright (C) 2013,2014
;;      "Mu Lei" known as "NalaGinrut" <NalaGinrut@gmail.com>
;;  This file is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.

;;  This file is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.

;;  You should have received a copy of the GNU General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

(define-module (lambdabit env)
  #:use-module (srfi srfi-1)
  #:use-module ((rnrs) #:select (define-record-type))
  #:use-module (lambdabit utils))

(module-export-all! (current-module))

;; Environment representation.

(define global-env '())
(define (set-global-env! e) (set! global-env e)) ; for primitive generation

(define-record-type var
  (fields 
   id global? 
   (mutable refs)
   (mutable sets)
   (mutable def)
   (mutable needed?)
   primitive))

(define-record-type primitive
  (fields
   nargs
   (mutable constant-folder)
   (mutable eta-expansion)
   unspecified-result?))

;; some init values
(define null-refs '())
(define null-sets '())
(define not-def #f)
(define no-needed #f)
(define not-primitive #f)

(define (make-primitive-var id prim)
  (make-var id 'primitive null-refs null-sets not-def no-needed prim))

(define (make-global-var id def)
  (make-var id 'global null-refs null-sets def no-needed not-primitive))

(define (make-nodef-global-var id)
  (make-var id 'global null-refs null-sets not-def no-needed not-primitive))

;; var-global? == #f means local
(define (make-local-var id def)
  (make-var id #f null-refs null-sets def no-needed not-primitive))

(define (var-bare-id v) (var-id v)) ; for code-generation

(define (var=? x y)
  (and (and (var? x) (var? y))
       (id=? (var-id x) (var-id y))   ; same symbol
       (equal? (var-def x) (var-def y)))) ; defined in the same place
(define (id=? x y) (eq? x y))

(define allow-forward-references? (make-parameter #t))

(define (env-lookup env id)
  ;;(format #t "allow-forward-references? ==> ~a~%id ==> ~a~%" (allow-forward-references?) id)
  (or (any (lambda (x) (and (id=? (var-id x) id) x)) env) ; find the id
      ;; We didn't find it. If reasonable to do so, add it to the env.
      ;; This makes it possible to have forward references at the top level.
      (if (allow-forward-references?)
        (let ((x (make-nodef-global-var id)))
          (append! env (list x))
    ;;      (format #t "x: ~a~%" (->list x))
          x)
        (compiler-error "env-lookup: variable referenced before its definition:" id))))

;; NOTE: need side-effect definitly
(define (env-extend env ids def)
  (append! (map (lambda (id)
                  (make-var id #f '() '() def #f #f))
                ids)
           env))

;; extra code environment : list of AST nodes
;; To hold code generated by the compiler that must be compiled along with the
;; rest of the program (e.g. primitive eta-expansions).
;; All this code needs to be generated before compilation begins, and will be
;; merged with the rest of the program after parsing.
(define extra-code-env '())
(define (add-extra-code c) (set! extra-code-env (cons c extra-code-env)))
