;;  Copyright (C) 2013
;;      "Mu Lei" known as "NalaGinrut" <NalaGinrut@gmail.com>
;;  This file is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.

;;  This file is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.

;;  You should have received a copy of the GNU General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

(define-module (lambdabit env)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)
  #:use-module (lambdabit utils))

(module-export-all! (current-module))

;; Environment representation.

(define global-env '())
(define (set-global-env! e) (set! global-env e)) ; for primitive generation

(define-record-type var
  (make-var id global? refs sets def needed? primitive)
  var?
  (id var-id var-id!)
  (global? var-global? var-global?!)
  (refs var-refs var-refs!)
  (sets var-sets var-sets!)
  (def var-def var-def!)
  (needed? var-needed? var-needed?!)
  (primitive var-primitive var-primitive!))

(define-record-type primitive
  (make-primitive nargs constant-folder eta-expansion unspecified-result?)
  primitive?
  (nargs primitive-nargs primitive-nargs!)
  (constant-folder primitive-constant-folder primitive-constant-folder!)
  (eta-expansion primitive-eta-expansion primitive-eta-expansion!)
  (unspecified-result? primitive-unspecified-result? primitive-unspecified-result?!))

(define (make-primitive-var id prim)
  (make-var id #t '() '() #f #f prim))

(define (make-global-var id def)
  (make-var id #t '() '() def #f #f))

(define (make-local-var id def)
  (make-var id #f '() '() def #f #f))

(define (var-bare-id v) (syntax->datum (var-id v))) ; for code-generation

(define (var=? x y)
  (and (id=? (var-id  x) (var-id  y))   ; same symbol
       (eq?  (var-def x) (var-def y)))) ; defined in the same place
(define (id=? x y) (eq? (syntax->datum x) (syntax->datum y)))

(define allow-forward-references? (make-parameter #t))

(define (env-lookup env id)
  (or (any (lambda (x) (and (id=? (var-id x) id) x)) env) ; find the id
      ;; We didn't find it. If reasonable to do so, add it to the env.
      ;; This makes it possible to have forward references at the top level.
      (let ((x (make-var id #t '() '() #f #f #f)))
        (unless (allow-forward-references?)
          (compiler-error "variable referenced before its definition:" id))
        (append! env (list x))
        x)))

;; FIXME: do we need side-effect here?
(define (env-extend env ids def)
  (append (map (lambda (id)
                 (make-var id #f '() '() def #f #f))
               ids)
          env))

;; extra code environment : list of AST nodes
;; To hold code generated by the compiler that must be compiled along with the
;; rest of the program (e.g. primitive eta-expansions).
;; All this code needs to be generated before compilation begins, and will be
;; merged with the rest of the program after parsing.
(define extra-code-env '())
(define (add-extra-code c) (set! extra-code-env (cons c extra-code-env)))
